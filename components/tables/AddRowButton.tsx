"use client";

import { useEffect, useMemo, useState } from "react";
import { useRouter } from "next/navigation";
import { normalizeForType } from "@/lib/mysql-normalize";
import { Dialog, DialogContent, DialogHeader, DialogTitle } from "@/components/ui/dialog";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { ScrollArea } from "@/components/ui/scroll-area";
import { toast } from "sonner";

type Meta = {
  ok: boolean;
  schema: string;
  table: string;
  primaryKey: string[];
  columns: {
    name: string;
    type: string;
    isNullable: boolean;
    isPrimary: boolean;
    default: any;
    extra: string | null;
  }[];
};

function isAutoGeneratedPrimary(c: Meta["columns"][number]) {
  if (!c.isPrimary) return false;
  const extra = (c.extra || "").toLowerCase();
  if (extra.includes("auto_increment")) return true;
  if (extra.includes("default_generated")) return true;
  const def = typeof c.default === "string" ? c.default.trim().toLowerCase() : "";
  if (!def) return false;
  if (/\b(uuid|gen_random_uuid|random_uuid|guid|newid)\s*\(/.test(def)) return true;
  if (/\bcurrent_timestamp\b/.test(def)) return true;
  if (/\bnow\(\)/.test(def)) return true;
  return false;
}

function parseLen(t: string) {
  const m = t.toLowerCase().match(/(char|varchar)\s*\(\s*(\d+)\s*\)/);
  return { base: m?.[1] || t.toLowerCase(), len: m ? parseInt(m[2], 10) : undefined };
}

function isUuidPrimaryNeedingValue(c: Meta["columns"][number]) {
  if (!c.isPrimary) return false;
  if (isAutoGeneratedPrimary(c)) return false;
  const { base, len } = parseLen(c.type);
  const likelyUuidLen = len && len >= 32 && len <= 64;
  const nameHint = /(^id$|uuid)/i.test(c.name);
  return (base === "char" || base === "varchar") && (likelyUuidLen || nameHint);
}

function genUUID() {
  if (typeof crypto !== "undefined" && "randomUUID" in crypto) return crypto.randomUUID();
  return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, c => {
    const r = (Math.random() * 16) | 0;
    const v = c === "x" ? r : (r & 0x3) | 0x8;
    return v.toString(16);
  });
}

function nowDate() {
  return new Date().toISOString().slice(0, 10);
}
function nowTime() {
  return new Date().toISOString().slice(11, 16);
}
function nowDateTimeLocal() {
  return new Date().toISOString().slice(0, 16);
}
function resolveInputType(mysqlType: string) {
  const t = mysqlType.toLowerCase();
  if (t.includes("datetime") || t.includes("timestamp")) return "datetime-local";
  if (t === "date") return "date";
  if (t === "time") return "time";
  if (/(int|decimal|double|float|year)/.test(t)) return "number";
  return "text";
}

export default function AddRowButton({
  connectionId,
  tableId,
  label = "Add row",
}: {
  connectionId: string;
  tableId: string;
  label?: string;
}) {
  const router = useRouter();
  const [open, setOpen] = useState(false);
  const [meta, setMeta] = useState<Meta | null>(null);
  const [form, setForm] = useState<Record<string, string>>({});
  const [busy, setBusy] = useState(false);
  const [err, setErr] = useState<string | null>(null);

  useEffect(() => {
    if (!open) return;
    let alive = true;
    setErr(null);
    fetch(`/api/connections/${connectionId}/tables/${encodeURIComponent(tableId)}/meta`, { cache: "no-store" })
      .then(r => r.json())
      .then(d => {
        if (!alive) return;
        setMeta(d);
        const init: Record<string, string> = {};
        (d.columns || []).forEach((c: any) => {
          const t = c.type.toLowerCase();
          if (t.includes("datetime") || t.includes("timestamp")) init[c.name] = nowDateTimeLocal();
          else if (t === "date") init[c.name] = nowDate();
          else if (t === "time") init[c.name] = nowTime();
          else if (isUuidPrimaryNeedingValue(c)) init[c.name] = genUUID();
          else init[c.name] = "";
        });
        setForm(init);
      })
      .catch(() => {
        setErr("Failed to load metadata");
        toast.error("Failed to load metadata");
      });
    return () => {
      alive = false;
    };
  }, [open, connectionId, tableId]);

  const insertableCols = useMemo(() => {
    if (!meta) return [];
    return meta.columns.filter(c => {
      const extra = (c.extra || "").toLowerCase();
      if (extra.includes("auto_increment")) return false;
      if (isAutoGeneratedPrimary(c)) return false;
      return true;
    });
  }, [meta]);

  const requiredCols = useMemo(() => {
    if (!meta) return [];
    return insertableCols.filter(c => {
      if (c.isNullable) return false;
      const def = typeof c.default === "string" ? c.default.trim() : c.default;
      if (def !== null && def !== undefined && def !== "") return false;
      return true;
    });
  }, [meta, insertableCols]);

  async function onSubmit(e: React.FormEvent) {
    e.preventDefault();
    if (!meta) return;
    setBusy(true);
    setErr(null);
    const missing = requiredCols.map(c => c.name).filter(n => (form[n] ?? "").trim() === "");
    if (missing.length) {
      const m = `Required: ${missing.join(", ")}`;
      setBusy(false);
      setErr(m);
      toast.error(m);
      return;
    }
    const data: Record<string, unknown> = {};
    for (const c of insertableCols) {
      const raw = form[c.name] ?? "";
      if (raw === "") continue;
      data[c.name] = normalizeForType(raw, c.type);
    }
    try {
      const res = await fetch(
        `/api/connections/${connectionId}/tables/${encodeURIComponent(tableId)}/insert`,
        { method: "POST", headers: { "Content-Type": "application/json" }, body: JSON.stringify({ data }) }
      );
      const j = await res.json();
      if (!res.ok || !j.ok) throw new Error(j?.detail || j?.error || "Insert failed");
      toast.success("Row added");
      setOpen(false);
      router.refresh();
    } catch (e: any) {
      const m = String(e.message || e);
      setErr(m);
      toast.error(m);
    } finally {
      setBusy(false);
    }
  }

  return (
    <>
      <Button variant="outline" onClick={() => setOpen(true)}>{label}</Button>
      <Dialog open={open} onOpenChange={setOpen}>
        <DialogContent className="max-w-xl">
          <DialogHeader>
            <DialogTitle>Add row</DialogTitle>
          </DialogHeader>
          {!meta ? (
            <div className="text-sm text-muted-foreground">Loadingâ€¦</div>
          ) : (
            <form onSubmit={onSubmit} className="space-y-4">
              <div className="grid grid-cols-1 md:grid-cols-2 gap-3">
                {insertableCols.map(c => {
                  const type = resolveInputType(c.type);
                  const isRequired = !!requiredCols.find(r => r.name === c.name);
                  return (
                    <div key={c.name} className="space-y-1.5">
                      <Label htmlFor={`add-${c.name}`}>
                        {c.name} <span className="text-xs text-muted-foreground">({c.type}{isRequired ? ", required" : ""})</span>
                      </Label>
                      <Input
                        id={`add-${c.name}`}
                        type={type}
                        value={form[c.name] ?? ""}
                        onChange={e => setForm(s => ({ ...s, [c.name]: e.target.value }))}
                        placeholder={c.isNullable ? "NULL allowed" : ""}
                      />
                    </div>
                  );
                })}
              </div>
              {err && (
                <ScrollArea className="max-h-28 rounded-md border border-red-300 p-2 text-sm text-red-700">
                  {err}
                </ScrollArea>
              )}
              <div className="flex justify-end gap-2">
                <Button variant="outline" type="button" onClick={() => setOpen(false)}>Cancel</Button>
                <Button type="submit" disabled={busy}>{busy ? "Saving..." : "Save"}</Button>
              </div>
            </form>
          )}
        </DialogContent>
      </Dialog>
    </>
  );
}